% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bmdd.R
\name{bmdd}
\alias{bmdd}
\title{Bimodal Dirichlet distribution (BMDD) for microbiome data}
\usage{
bmdd(
  W,
  type = c("count", "proportion"),
  Z = NULL,
  formula.Z = NULL,
  U = NULL,
  formula.U = NULL,
  Z.standardizing = TRUE,
  U.standardizing = TRUE,
  alp.eta = FALSE,
  alp.kap = FALSE,
  pi.xi = FALSE,
  pi.zeta = FALSE,
  para.alp.init = NULL,
  para.pi.init = NULL,
  gam.init = NULL,
  iterlim = 500,
  tol = 1e-06,
  trace = FALSE,
  inner.loop = TRUE,
  inner.iterlim = 20,
  inner.tol = 1e-06,
  inner.trace = FALSE,
  alp.iterlim = 20,
  alp.tol = 1e-06,
  alp.min = 0.001,
  alp.max = 1000,
  para.alp.min = -10,
  para.alp.max = 10,
  pi.iterlim = 20,
  pi.tol = 1e-06,
  para.pi.min = -100,
  para.pi.max = 100
)
}
\arguments{
\item{W}{data frame or matrix representing count table or table of samples from bimodal Dirichlet distribution.
Row: taxa; column: samples. NAs are not allowed.}

\item{type}{either 'count' or 'proportion'. If \code{W} is a count table of microbiome data, then \code{type = 'count'}; and
if \code{W} is a table of samples from bimodal Dirichlet distribution, then \code{type = 'proportion'}.}

\item{Z}{data frame of sample covariates. The rows of \code{Z} correspond to the columns of \code{W}. If NULL, no sample covariates are incorporated.}

\item{formula.Z}{formula of regression models on sample covariates. For example: \code{formula = '~z1*z2+z3'}, where z1, z2, and z3 are some of the
columns of \code{Z}. If \code{Z} is non-NULL, and \code{formula.Z} is NULL, then the \code{formula.Z} is set to be all columns of \code{Z} automatically.}

\item{U}{data frame of taxon covariates. The rows of \code{U} correspond to the rows of \code{W}. If NULL, no taxon covariates are incorporated.}

\item{formula.U}{formula of regression models on taxon covariates. If \code{U} is non-NULL, and \code{formula.U} is NULL,
then the \code{formula.U} is set to be all columns of \code{U} automatically.}

\item{Z.standardizing}{a logical value indicating whether to standardize the data. If TRUE, the numerical columns in \code{formula.Z} will be standardized.}

\item{U.standardizing}{a logical value indicating whether to standardize the data. If TRUE, the numerical columns in \code{formula.U} will be standardized.}

\item{alp.eta}{a logical value indicating whether to incorporate sample covariates for alpha.}

\item{alp.kap}{a logical value indicating whether to incorporate taxon covariates for alpha.}

\item{pi.xi}{a logical value indicating whether to incorporate sample covariates for pi.}

\item{pi.zeta}{a logical value indicating whether to incorporate taxon covariates for pi.}

\item{para.alp.init}{a vector of initial values for (alpha0, alpha1) or (eta0, eta1, kappa0, kappa1).
If no covariates are considered, then the length of \code{para.alp.init} is 2m; otherwise,
the length of \code{para.alp.init} is 2(mpk+nql), where k=1 if \code{alp.eta} is TRUE and 0 otherwise, and l=1
if \code{alp.kap} is TRUE and 0 otherwise. If not given, the function will do the initialization using random numbers.}

\item{para.pi.init}{a vector of initial values for pi or (xi, zeta).
If no covariates are considered, then the length of \code{para.pi.init} is m; otherwise,
the length of \code{para.pi.init} is mpk+nql, where k=1 if \code{pi.xi} is TRUE and 0 otherwise, and l=1
if \code{pi.zeta} is TRUE and 0 otherwise. If not given, the function will do the initialization.}

\item{gam.init}{initial values of gamma. If not given, the function will do the initialization.}

\item{iterlim}{maximum number of iterations of the variational EM algorithm.}

\item{tol}{a numerical value giving the tolerance in the relative change in the estimates of alpha0 and alpha1 below which
the algorithm is considered to be converged.}

\item{trace}{a logical value indicating whether to print the iteration process.}

\item{inner.loop}{a logical value indicating whether to conduct iteration across j=1,...,m inside each E-step.}

\item{inner.iterlim}{maximum number of iterations of the loop inside each E-step.}

\item{inner.tol}{a numerical value giving the tolerance in the relative change in gamma inside the E-step.}

\item{inner.trace}{a logical value indicating whether to print the iteration process inside the E-step.}

\item{alp.iterlim}{maximum number of iterations in the optimization function (nlminb) for alpha0 and alpha1 in M-step.}

\item{alp.tol}{tolerance in the optimization function for alpha0 and alpha1 in M-step.}

\item{alp.min}{minimum alpha0 and alpha1 value.}

\item{alp.max}{maximum alpha0 and alpha1 value.}

\item{para.alp.min}{maximum value of the regression coefficients for alpha0 and alpha1.}

\item{pi.iterlim}{maximum number of iterations in the optimization function (nlminb) for pi in M-step.}

\item{pi.tol}{tolerance in the optimization function for pi in M-step.}

\item{para.pi.min}{maximum value of the regression coefficients for pi.}
}
\value{
A list with the elements
\item{gamma}{estimate of gamma}
\item{beta}{estimate of beta. If \code{type='porportion'}, no this item is returned.}
\item{alpha}{a list with first element being the estimate of alpha0 and second the estimate of alpha1.}
\item{pi}{estimate of pi}
\item{para.alpha}{if no covariates are incorporated, then \code{para.alpha} is (alpha0, alpha1) itself. if there are covariates,
then \code{para.alpha} is the estimate of the regression coefficients. The length of \code{para.alpha} is the same as \code{para.alp.init}}
\item{para.pi}{if no covariates are incorporated, then \code{para.pi} is pi itself. if there are covariates,
then \code{para.pi} is the estimate of the regression coefficients. The length of \code{para.pi} the is same as \code{para.pi.init}}
}
\description{
The function implements a variational EM algorithm for estimating the parameters in bimodal Dirichlet distribution.
For the microbiome data, the unobserved true compositions are assumed to follow the bimodal Dirichlet distribution,
thus the function also estimates the posterior distribution of the true compositions.
}
\details{
Model and Notations: Assume there are m taxa and n samples in the microbiome count data.
Given the sequencing depth and true compositions of a sample, which is assumed to be from the bimodal Dirichlet distribution,
the counts of taxa in the sample can be considered following multinormial distribution. Let (alpha_1,...,alpha_m) be the
parameters of a Dirichlet distribution. The bimodal Dirichlet distribution allows two possibilities for each alpha_i (i.e, the two
modals of the distribution of the corresponding composition), alpha0_i and alpha1_i, and the probability of being alpha1_i is referred to as pi_i.
Let pi = (pi_1,pi_2,...,pi_m), alpha0 = (alpha0_1,alpha0_2,...,alpha0_m) and alpha1 = (alpha1_1,alpha1_2,...,alpha1_m).
We use variational EM algorithm to estimate the parameters based on the mean-field approximation for the posterior.
Use delta_ij~Bernoulli(pi_i) to indicate which modal the taxon i in sample j is from. The mean-field approximation for the posterior of delta_ij
is Bernoulli(gamma_ij). The mean-filed approximation for the posterior of true compositions of sample j is Dirichlet(beta_1j,beta_2j,...,beta_mj).
Let gamma and beta be m by n matrices with (i,j)th entry being gamma_ij and beta_ij respectively.

Incorporating sample or taxon covariates: We incorporate the covariates for alpha through the log linear model, and pi the logistic model.
Suppose the number of regression variables (after considering the dummy variables) from the sample covariates is p, and from taxon covariates is q.
Use eta0 and eta1 to denote the regression coefficients on sample covariates for alpha0 and alpha1,
and use kappa0 and kappa1 to denote the regression coefficients on taxon covariates for alpha0 and alpha1.
Use xi to denote the regression coefficients on sample covariates for pi,
and use zeta to denote the regression coefficients on taxon covariates for pi.
Thus, the lengths of eta0, eta1 and xi are mp and the lengths of kappa0, kappa1 and zeta are nq.
In this case, alpha0, alpha1 and pi are matrices of m by n.
}
\examples{

#This is an example of using BMDD as an zero-imputation method for LinDA to identify colorectal cancer
#associated bacterial species. Data "phy" is a phyloseq-class experiment-level object.
#LinDA is a differential abundance analysis method for microbiome data.
#The package is available at https://CRAN.R-project.org/package=MicrobiomeStat
#and https://github.com/zhouhj1994/LinDA.
#Reference for the dataset: Yu et al. (2017). Metagenomic analysis of faecal microbiome as a tool
#towards targeted non-invasive biomarkers for colorectal cancer.
#Reference for LinDA: Zhou et al. (2022). LinDA: linear models for differential abundance analysis
#of microbiome compositional data.

#install packages "phyloseq", "MicrobiomeStat"
library(BMDD)

data(phy)

otu_filter <- function(feature.dat, prev = 0.1, dep = 1000){
  idx <- apply(feature.dat, 1, function(x) sum(x > 0) > (ncol(feature.dat) * prev))
  idx2 <- colSums(feature.dat) > dep
  return(feature.dat[idx, idx2])
}
feature.dat <- as.data.frame(as.matrix(phyloseq::otu_table(phy)))
meta.dat <- as.data.frame(as.matrix(phyloseq::sample_data(phy)))
meta.dat$grp <- as.factor(meta.dat$grp)
feature.dat <- otu_filter(feature.dat)
meta.dat <- meta.dat[colnames(feature.dat), ]

m <- nrow(feature.dat)
n <- ncol(feature.dat)

bmdd.obj <- bmdd(W = feature.dat, type = 'count', trace = TRUE)

# posterior mean
beta <- bmdd.obj$beta
post.mean <- t(t(beta) / colSums(beta))

## generate 100 posterior samples of the composition for each sample
zero.fun <- function(X) {
  X <- t(apply(X, 1, function (x) {
    if(all(x == 0)) {
      x[x == 0] <- min(X[X != 0])
    } else {
      x[x == 0] <- min(x[x != 0])
    }
    return(x)
  }))
  return(X)
}

K <- 100
beta <- beta[, rep(1 : n, K)]
X <- matrix(rgamma(m * n * K, beta, 1), m)
X <- t(t(X) / colSums(X))
if(any(X == 0)) {
  X <- zero.fun(X)
  X <- t(t(X) / colSums(X))
}
colnames(X) <- paste0('sample', 1 : (n * K))
rownames(X) <- rownames(beta)

## apply LinDA to the proportion matrix, with 100 replicates per sample.
id <- factor(rep(1 : n, K))
grp <- rep(meta.dat$grp, K)
Z <- cbind.data.frame(grp, id)
rownames(Z) <- colnames(X)

linda.bmdd.obj <- MicrobiomeStat::linda(feature.dat = X, meta.dat = Z,
                                        formula = "~grp+(1|id)", feature.dat.type = "proportion")

# apply LinDA to the original count matrix
linda.obj <- MicrobiomeStat::linda(feature.dat = feature.dat, meta.dat = meta.dat,
                                   formula = "~grp", feature.dat.type = "count")
}
\references{
Huijuan Zhou, Jun Chen, and Xianyang Zhang. BMDD: A probabilistic framework for accurate imputation of zero-inflated microbiome sequencing data.
}
\author{
Huijuan Zhou \email{huijuanzhou2019@gmail.com}
Jun Chen \email{chen.jun2@mayo.edu}
Xianyang Zhang \email{zhangxiany@stat.tamu.edu}
}
